classdef opp_diff_current
    %OPP_DIFF processes the differential-mode tdd objective    
    
    properties
        x = [];
        tau = [];
        soc = {};        
        testing = 1;
    end
    
    methods
        function obj = opp_diff_current(floating)
            %OPP_DIFF Construct an instance of this class
            %   Detailed explanation goes here
            if nargin >= 1 || floating == false
                mpol('x_tau', 5, 1);
                obj.tau = meas(x_tau);         
                obj.x = x_tau;
            end
        end
        
        function m_out = mass(obj)
            m_out = mass(obj.tau);
        end


        function sc = supp_con(obj)
            %support constraint
            sc = [sum(obj.x(1:2).^2) == 1; 
                obj.x(3:5).^2 <= 1];
        end
       

        function [objective] = objective_common_mode(obj)
            %create the common-mode current

            % Q = (eye(3) - ones(3)/3);
            
            
            xi = obj.x(3:5);
            
            Q = ones(3);

            if obj.testing==0
                quad = (xi'*Q*xi)*(1/3);
            else
                quad = xi'*eye(3)*xi*(1/3);
            end

            objective = pi^2 * (2*pi) * mom(quad);
            % objective = 0;
        end

        function [objective] = objective_diff(obj)
            %create the common-mode current

            Q = (eye(3) - ones(3)/3);
            
            
            xi = obj.x(3:5);
            
            % Q = ones(3);

            if obj.testing==0
                quad = (xi'*Q*xi)*(1/3);
            else
                % quad = xi'*eye(3)*xi*(1/3);
                % quad = xi(1)^2;
                % quad = xi(2)^2;
                quad = sum(xi.^2)/3;
            end

            objective = pi * (2*pi)^2 * mom(quad);
            % objective = 0;
        end

        function marg_con = con_diff(obj, d, three_phase_mom)
            %form the three-phase 

            va = mmon(obj.x([1, 2, 3]), d);
            vb = mmon(obj.x([1, 2, 4]), d);
            vc = mmon(obj.x([1, 2, 5]), d);

            marg_v = [mom(va), mom(vb), mom(vc)];

            marg_con = (marg_v == three_phase_mom);
            marg_con = reshape(marg_con, [], 1);
        end
    
        %fetch the recovered entries
        function M = mmat(obj)
            if isempty(obj.tau)
                M = [];
            else
                M = double(mmat(obj.tau));
            end
        end

        function Mc = mmat_corner(obj)
            if isempty(obj.tau)
                Mc = [];
            else                
                Mc = double(mom([1; obj.x]*[1; obj.x]'));
            end
        end
    end
end

