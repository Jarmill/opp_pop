classdef opp_mode
    %OPP_MODE Measures describing the trajectory at mode m 
    %(before switch m, or at the end of the sequence)
    %   Detailed explanation goes here
    
    properties
        mode;          %the mode m (defines the id)
        opts;          %relevant options for the mode
        levels;        %locations for each inverter voltage level
        L;             %levels of the inverter        
        transition;    %guard measures for the partition staying within the level (no switching)
        vars;          %basic variable type
    end
    
    methods
        function obj = opp_mode(m, lsupp_ref, opts)
            %OPP_MODE Construct an instance of this class
            %   create locations
            obj.mode = m;
            obj.L = opts.L;
            
            N = length(opts.L);
            P = opts.partition;
            obj.levels = cell(N, P);
            obj.transition = cell(N, P-1);

            %define the generic support set
            lsupp_base = lsupp_ref;

            vars = lsupp_base.vars;           
            obj.vars = vars;

            %define the terminal set
            %terminate
            Xstop = [vars.x(1)==1; vars.x(2)==0; lsupp_base.X(2:end)];
            if m==0                
               lsupp_base.X_init = Xstop;
            elseif m==opts.k || (opts.early_stop && (mod(m, 2)==0))
                lsupp_base.X_term = Xstop;
            end

            %TODO: define grid-side filter dynamics
            %define the dynamics within the mode

            X_partition = support_partition(opts.partition, vars);
            

            f = all_dynamics(vars, opts);

            objective_mode = all_objective_mode(vars, opts);
            

            % loc_id = N*opts.partition*m + reshape(1:(N*opts.partition), N, []);
            %create locations for each level
            for n = 1:N
                curr_f = f(:, n);
                curr_objective = objective_mode(n);                
                for j = 1:P
                    % curr_id = loc_id(n, j);
                    curr_id = sprintf('%d_%d_%d', m, n, j);

                    curr_lsupp = lsupp_base;

                    if j>1
                        curr_lsupp.X_init = [];
                    end

                    if opts.partition > 1
                        curr_lsupp.X = [curr_lsupp.X; X_partition(j)];
                    end
                    cell_info = struct('mode', m, 'partition', p, 'level', n, 'id', id);
                    obj.levels{n, j} = opp_location(curr_lsupp, curr_f, curr_objective, cell_info);

                end
            end

            %create transitions between the partition 
            %when advancing the angle theta
            
            % gtop =    guard(1, vars, loc1, loc2, Xgtop, x);
            for n=1:N
                for j=1:P-1
                    curr_trans_id = sprintf('trans_%d_%d_%d', n, j, j+1);
                    
                    obj.transition{n, j} = guard(curr_trans_id, lsupp_base.vars, ...
                        obj.levels{n, j}, obj.levels{n, j+1}, curr_supp, vars.x);
                end
            end
        end

        %% functions used in the constructor

        function objective = all_objective_mode(vars, opts)
            %return the mode-objective at each level
            %
            %TODO: 
            %the scaling factors may be wrong for inductance and
            %capacitance. check this later.
            %
            N = length(opts.L);
            if (length(vars.x)==3) || (im(opts.Z_load) == 0)                      
                %purely resistive
                objective = (opts.L.^2);
            elseif (imag(opts.Z_load) >= 0)
                
                %inductive load
                %i' = -(R/L)i + (1/L) v
                %per-unit system, ignore the L value
                inductance = imag(opts.Z_load)/(2*pi*opts.f0);
                % resistance= real(opts.Z_load);                
                % f_load = -(resistance)/(inductance)*vars.x(4) + Lscale;
                objective = vars.x(4)*(N/inductance)^2*(opts.L).^2;
            else
                 %vc' = (v-vc)/(R*C)
                 %per-unit, ignore (R*C) factor
                 %TODO: v is from the voltage source. Modify when it is 
                 %filtered by a grid-side filter
                 capacitance= -imag(opts.Z_load)*(2*pi*opts.f0);
                 resistance= real(opts.Z_load);  
                 RC = resistance*capacitance;
                 % f_load = Lscale - vars.x(4)/(resistance*capacitance);
                 objective = (opts.L.^2) + 2*(opts.L)*vars.x(4)*(N/RC) + (N/RC)^2*vars.x(4)^2;
            end
        end
        

        function f = all_dynamics(vars, opts)
            %create the dynamics as a matrix f
            %row: each level
            %column: each state
            f_trig = 2*pi*[-vars.x(2); vars.x(1)];
            f_phi = vars.x(3);
            f_clock = 1;
            f_load = load_dynamics(vars, opts);

            % f = [f_trig; f_phi; f_load];
            N = length(opts.L);
            f_basic = [f_trig; f_phi; f_clock] * ones(1, N);

            f = [f_basic; f_load];
        end


        function f_load = load_dynamics(vars, opts)
            %dynamics in the mode
            %(trig spinning around a circle, clock increasing, load
            %charging/modifying the current)
            %vars: variables (t, x)
            %opts: options from opp_options
            %n: level of the inverter

            %scaled inverter value
            Lscale = opts.L/max(abs(opts.L));
            % u_curr = opts.L(n)/max(abs(opts.L));           

            %dynamics of the load
            if (length(vars.x)==3) || (im(opts.Z_load) == 0)                      
                %purely resistive
                f_load = [];
            elseif (imag(opts.Z_load) >= 0)
                %inductive load
                %i' = -(R/L)i + (1/L) v
                %per-unit system, ignore the L value
                inductance = imag(opts.Z_load)/(2*pi*opts.f0);
                resistance= real(opts.Z_load);                
                f_load = -(resistance)/(inductance)*vars.x(4) + Lscale;
            else
                 %vc' = (v-vc)/(R*C)
                 %per-unit, ignore (R*C) factor
                 %TODO: v is from the voltage source. Modify when it is 
                 %filtered by a grid-side filter
                 capacitance= -imag(opts.Z_load)*(2*pi*opts.f0);
                 resistance= real(opts.Z_load);  
                 f_load = Lscale - vars.x(4)/(resistance*capacitance);
            end
        end
    
        %% functions used to describe constraints
        function liou = flow(obj, d)
            %return the continuity equation within the mode
            [N, P] = size(obj.levels);
            liou = cell(N, P);
            %start with continuity within the location
            %positive: incoming, negative: outgoing
            for n=1:N
                for p = 1:P
                    liou{n, p} = obj.levels{n, p}.liou_con(d);
                end
            end

            %now handle transitions within the mode
            for n=1:N
                for p = 1:P-1
                    trans_loss = obj.transition{n, p}.reset_push(d);
                    liou{n, p} = liou{n, p} - trans_loss;
                    liou{n, p+1} = liou{n, p+1} + trans_loss;
                end
            end

            %return liou
            %the manager will sew together jumps between multiple modes.

        end


        %fetching moments

        function harm = voltage_harmonics_mom(obj, vars, harm_in)
            %voltage harmonics constraints
            harm= mom(vars.x(1))*zeros;
            
            [N, P] = size(obj.levels);

            for n=1:N
                for p = 1:P            
                    [~, harm_mom] = obj.levels{n, p}.voltage_harmonics_mom(obj, vars, harm_in);       
                    harm = harm+harm_mom;                    
                end
            end
        end


        function harm = load_harmonics_mom(obj, vars, harm_in)
            %voltage harmonics constraints
            % harm= mom(p)*0;
            
            if (length(vars.x)==3) || (im(obj.opts.Z_load) == 0)                      
                %purely resistive
                harm = obj.voltage_harmonics_mom(vars, harm_in);
            else
                harm_eval = [vars.x(1).^harm_in.index_cos; vars.x(1).^harm_in.index_sin];
                if (imag(obj.opts.Z_load) >= 0)
                    
                    %inductive load
                    %i' = -(R/L)i + (1/L) v
                    %per-unit system, ignore the L value
                    inductance = imag(obj.opts.Z_load)/(2*pi*obj.opts.f0);
                    % resistance= real(opts.Z_load);                
                    % f_load = -(resistance)/(inductance)*vars.x(4) + Lscale;
                    harm = (harm_eval.*vars.x(4)) * (N/inductance) .*(obj.opts.L);
                else
                     %vc' = (v-vc)/(R*C)
                     %per-unit, ignore (R*C) factor
                     %TODO: v is from the voltage source. Modify when it is 
                     %filtered by a grid-side filter
                     capacitance= -imag(obj.opts.Z_load)*(2*pi*obj.opts.f0);
                     resistance= real(obj.opts.Z_load);  
                     RC = resistance*capacitance;
                     % f_load = Lscale - vars.x(4)/(resistance*capacitance);
                     harm = obj.opts.L*harm_eval - vars.x(4)*(N/RC)
                     + 2*(obj.opts.L)*vars.x(4)*(N/RC) + (N/RC)^2*vars.x(4)^2;
                end
            end

            harm_eval = [vars.x(1).^harm_in.index_cos; vars.x(1).^harm_in.index_sin];
            [N, P] = size(obj.levels);

            for n=1:N
                for p = 1:P
                    occ_curr = obj.levels{n, p}.sys{1}.meas_occ;

                    harm_curr = mom(occ_curr.var_sub(vars, harm_eval));
                    harm = harm+obj.opts.L(n)*harm_curr;                    
                end
            end
        end

        %TODO: current harmonics

        function mass_init_mode = initial_mass(obj)
            %return the mass of the initial measure in this mode
            mass_init_mode = [];
            [N, P] = size(obj.levels);
            mass_init_mode = zeros(N, P)*mom(obj.vars.x(1));

            for n=1:N
                for p = 1:P
                    mass_init_mode(n, p) = obj.levels{n, p}.mass_init();
                    % mass_init_mode = mass_init_mode + obj.levels{n, p}.mass_init();
                end
            end
        end

        function mass_term_mode = terminal_mass(obj)
            %return the mass of the initial measure in this mode
            mass_term_mode = [];
            [N, P] = size(obj.levels);
            mass_term_mode = zeros(N, P)*mom(obj.vars.x(1));

            for n=1:N
                for p = 1:P
                    mass_term_mode(n, p) = obj.levels{n, p}.mass_term();
                    % mass_init_mode = mass_init_mode + obj.levels{n, p}.mass_init();
                end
            end
        end

        function imon = init_monom(obj, d)
            %moments of the initial measure
            [N, P] = size(obj.levels);
            imon = cell(N, P);
            for n=1:N
                for p = 1:P
                    imon = obj.levels{n, p}.init.mom_monom(d);
                end
            end
        end

        function trmon = trig_occ_monom(obj, d)
            %get moments of the occupation measure
            %for the (c, s) marginal
            [N, P] = size(obj.levels);
            trmon = cell(N, P);

            
            for n=1:N
                for p = 1:P
                    x_curr= obj.levels{n, p}.sys{1}.vars.x;
                    x_curr_trig = x_curr(1:2);

                    v_curr = mmon(x_curr_trig, 0, d);

                    
                    trmon = mom(v_curr);
                end
            end
        end

        function tmon = term_monom(obj, d)
            %moments of the terminal measure
            [N, P] = size(obj.levels);
            tmon = cell(N, P);
            for n=1:N
                for p = 1:P                    
                      if isempty(obj.levels{n, p}.term)
                          tmon{n, p} = 0;
                      else
                          tmon{n, p} = obj.levels{n, p}.term.mom_monom(d);
                      end                                    
                end
            end
        end

        %TODO: three phase balance constraint
        function bmon = balance_term(obj, d)
            %three-phase balanced symmetry in the current
            
            bmon = 0;


        end

        function supp_con_out = supp_con(obj)
            %fetch all support constraints
            [N, P] = size(obj.levels);
            supp_con_out = cell(N, P);
            for n=1:N
                for p = 1:P                    
                    curr_loc = obj.levels{n, p};
                    if p<P
                        curr_trans = obj.transition{n, p};
                    else
                        curr_trans = [];
                    end
                    supp_con_out = [supp_con_out; curr_loc; curr_trans];
                end
            end
        end
    end
end

